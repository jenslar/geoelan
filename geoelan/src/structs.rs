use fit_rs::{get_video_uuid, structs::FitFile, structs::Point};
use std::collections::HashMap;
use std::path::{Path, PathBuf};

/// VIRB related struct, used by cam2eaf, eaf2geo.
/// Time span of recording session.
#[derive(Debug)]
pub struct SessionTimeSpan {
    pub start: chrono::Duration,
    pub end: chrono::Duration,
    pub uuid: Vec<String>,
}

/// VIRB related struct, used by match, cam2eaf.
/// The three file typs VIRB cameras generate.
#[derive(Debug, Clone, PartialEq)]
pub enum VirbFileType {
    FIT, // fit file, contains multiple uuids
    MP4, // hi-res video, contains single uuid
    GLV, // lo-res video, contains single uuid
}

/// VIRB related struct, used by match, cam2eaf
/// Used for matching and grouping VIRB video clips and FIT-files
/// into sessions.
#[derive(Debug, Clone)]
pub struct VirbFile {
    pub filetype: VirbFileType,
    pub path: PathBuf,
    pub uuid: Vec<Vec<String>>, // unique uuids, grouped into recording sessions
}

/// VIRB related methods, used by match, cam2eaf.
/// Varioud methods to detect whether an MP4, GLV (MP4),
/// or FIT-file was generated by a VIRB camera.
impl VirbFile {
    /// Creates new VirbFile struct, sets VirbFileType,
    /// and extracts uuid if present
    pub fn new(path: &Path, partial_return_on_error: bool) -> Option<VirbFile> {
        let ext = path.extension()?.to_str()?;
        match ext.to_lowercase().as_ref() {
            "mp4" => Some(VirbFile {
                path: path.to_owned(),
                filetype: VirbFileType::MP4,
                uuid: vec![get_video_uuid(&path).ok()?.map(|d| vec![d])?],
            }),
            "glv" => Some(VirbFile {
                path: path.to_owned(),
                filetype: VirbFileType::GLV,
                uuid: vec![get_video_uuid(&path).ok()?.map(|d| vec![d])?],
            }),
            "fit" => Some(VirbFile {
                path: path.to_owned(),
                filetype: VirbFileType::FIT,
                uuid: FitFile::parse_filter(&path, 161, partial_return_on_error)
                    .ok()?
                    .sessions()
                    .ok()?,
            }),
            _ => return None,
        }
    }

    pub fn type_to_str(&self) -> &str {
        match self.filetype {
            VirbFileType::GLV => "GLV",
            VirbFileType::MP4 => "MP4",
            VirbFileType::FIT => "FIT",
        }
    }

    pub fn is_glv(&self) -> bool {
        matches!(&self.filetype, VirbFileType::GLV)
    }
    pub fn is_mp4(&self) -> bool {
        matches!(&self.filetype, VirbFileType::MP4)
    }
    pub fn is_fit(&self) -> bool {
        matches!(&self.filetype, VirbFileType::FIT)
    }
}

/// VIRB related struct, used by match, cam2eaf
#[derive(Debug, Clone)]
pub struct VirbFiles {
    pub uuid: HashMap<String, Vec<VirbFile>>, // k: unique uuid, v: files containing k
    pub session: HashMap<String, Vec<String>>, // k: 1st uuid in session, v: uuid for entire session
    pub filetypes: HashMap<String, usize>,    // stats for glv/mp4/fit
}

/// VIRB related struct, used by cam2eaf. Will eventually be checked by eaf2geo.
/// Generic metadata describing video session + corresponding FIT-file.
pub struct FitMetaData {
    pub uuid: Vec<String>,
    pub sha256: String,
    pub file: String,
    pub size: u64,
    pub t0: chrono::DateTime<chrono::Utc>,
    pub start: chrono::Duration,
    pub end: chrono::Duration,
}

/// Mainly for generating KML to be able to switch between polyline and points
pub enum GeoType {
    POINT(Vec<Point>),
    LINE(Vec<Vec<Point>>),
}
